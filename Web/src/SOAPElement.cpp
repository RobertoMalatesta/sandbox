//
// SOAPElement.cpp
//
// $Id: //poco/1.1.0/XML/src/SOAPElement.cpp#1 $
//
// Library: Web
// Package: SOAP
// Module:  SOAPElement
//
// Copyright (c) 2006, Applied Informatics Software Engineering GmbH.
// and Contributors.
//
// Permission is hereby granted, free of charge, to any person or organization
// obtaining a copy of the software and accompanying documentation covered by
// this license (the "Software") to use, reproduce, display, distribute,
// execute, and transmit the Software, and to prepare derivative works of the
// Software, and to permit third-parties to whom the Software is furnished to
// do so, all subject to the following:
// 
// The copyright notices in the Software and this entire statement, including
// the above license grant, this restriction and the following disclaimer,
// must be included in all copies of the Software, in whole or in part, and
// all derivative works of the Software, unless such copies or derivative
// works are solely in the form of machine-executable object code generated by
// a source language processor.
// 
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
// SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
// FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
// ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
// DEALINGS IN THE SOFTWARE.
//


#include "Poco/Web/SOAPElement.h"
#include "Poco/Web/SOAPMessage.h"
#include "Poco/DOM/Document.h"
#include "Poco/DOM/Node.h"
#include "Poco/DOM/Element.h"
#include "Poco/DOM/Text.h"
#include "Poco/Web/SOAPHeader.h"
#include "Poco/RefCountedObject.h"
#include "Poco/Exception.h"


using Poco::RefCountedObject;
using Poco::InvalidArgumentException;
using Poco::XML::Document;
using Poco::XML::Node;
using Poco::XML::Element;
using Poco::XML::Text;
using Poco::XML::NodeList;


namespace Poco {
namespace Web {


//
// SOAPElementImpl
//
class SOAPElementImpl: public RefCountedObject
	/// SOAP element implementation abstract class.
{
public:
	virtual void add(const std::string& tag, const std::string& content)
	{
		if (envelopeTag() != tag) 
			throw InvalidArgumentException("Only envelope node add allowed. Override add() function to add other nodes.");
/*
		poco_check_ptr(_pDoc);
		Element* pEl = _pDoc->createElement(tag);

		if("" != content)
		{
			Text* pText = _pDoc->createTextNode(content);
			pEl->appendChild(pText);
		}

		_pDoc->appendChild(pEl);
		*/
		add(_pDoc, tag, content);
	}

	virtual NodeList* get(const std::string& name) const
	{
		poco_check_ptr(_pDoc);
		return _pDoc->getElementsByTagName(name);
	}

	virtual const std::string& envelopeTag() const = 0;
	virtual const std::string& headerTag() const = 0;
	virtual const std::string& bodyTag() const = 0;

	Document& document()
	{
		return *_pDoc;
	}

protected:
	SOAPElementImpl(): _pDoc(new Document)
	{
		poco_check_ptr(_pDoc);
	}

	SOAPElementImpl(Document* pDoc) : _pDoc(pDoc)
	{
		poco_check_ptr(_pDoc);
		_pDoc->duplicate();
	}

	virtual ~SOAPElementImpl()
	{
		_pDoc->release();
	}

	void add(Node* pNode, const std::string& tag, const std::string& content)
	{
		poco_check_ptr(pNode);
		Element* pEl = _pDoc->createElement(tag);

		if ("" != content)
		{
			Text* pText = _pDoc->createTextNode(content);
			pEl->appendChild(pText);
		}

		pNode->appendChild(pEl);
	}

private:
	SOAPElementImpl(const SOAPElementImpl&);
	SOAPElementImpl& operator = (const SOAPElementImpl&);

	Document* _pDoc;

	friend class SOAPElement;
};


//
// SOAPv11ElementImpl
//
class SOAPv11ElementImpl: public SOAPElementImpl
{
public:

	SOAPv11ElementImpl()
	{
	}

	SOAPv11ElementImpl(Document* pDoc): SOAPElementImpl(pDoc)
	{
	}

	const std::string& envelopeTag() const
	{
		return TAG_ENVELOPE;
	}

	const std::string& headerTag() const
	{
		return TAG_HEADER;
	}

	const std::string& bodyTag() const
	{
		return TAG_BODY;
	}

private:
	static const std::string TAG_ENVELOPE;
	static const std::string TAG_HEADER;
	static const std::string TAG_BODY;
};


const std::string SOAPv11ElementImpl::TAG_ENVELOPE = "SOAP-ENV:Envelope";
const std::string SOAPv11ElementImpl::TAG_HEADER = "SOAP-ENV:Header";
const std::string SOAPv11ElementImpl::TAG_BODY = "SOAP-ENV:Body";


///
/// SOAPv12ElementImpl
///
class SOAPv12ElementImpl: public SOAPElementImpl
{
public:
	SOAPv12ElementImpl()
	{
	}

	SOAPv12ElementImpl(Document* pDoc): SOAPElementImpl(pDoc)
	{
	}

	const std::string& envelopeTag() const
	{
		return TAG_ENVELOPE;
	}

	const std::string& headerTag() const
	{
		return TAG_HEADER;
	}

	const std::string& bodyTag() const
	{
		return TAG_BODY;
	}

private:
	static const std::string TAG_ENVELOPE;
	static const std::string TAG_HEADER;
	static const std::string TAG_BODY;
};


const std::string SOAPv12ElementImpl::TAG_ENVELOPE = "env:Envelope";
const std::string SOAPv12ElementImpl::TAG_HEADER = "env:Header";
const std::string SOAPv12ElementImpl::TAG_BODY = "env:Body";


///
/// SOAPElement
///
SOAPElement::SOAPElement(): _pImpl(new SOAPv11ElementImpl)
{
}

SOAPElement::SOAPElement(Version version): _pImpl(0)
{
	if (version == SOAPv11)
		_pImpl = new SOAPv11ElementImpl();
	else if (version == SOAPv12)
		_pImpl = new SOAPv12ElementImpl();
	else 
		InvalidArgumentException("Invalid or unsupported version passed to SOAPElement()");
}


SOAPElement::SOAPElement(const SOAPElement& elem): _pImpl(elem._pImpl)
{
	_pImpl->duplicate();
}


SOAPElement::SOAPElement(Document* pDoc, Version version): _pImpl(0)
{
	if (version == SOAPv11)
		_pImpl = new SOAPv11ElementImpl(pDoc);
	else if (version == SOAPv12)
		_pImpl = new SOAPv12ElementImpl(pDoc);
	else 
		InvalidArgumentException("Invalid or unsupported version passed to SOAPElement()");
}


SOAPElement::~SOAPElement()
{
	_pImpl->release();
}


void SOAPElement::add(const std::string& tag, const std::string& content)
{
	_pImpl->add(tag, content);
}


void SOAPElement::add(Node* pNode, const std::string& tag, const std::string& content)
{
	_pImpl->add(pNode, tag, content);
}


NodeList* SOAPElement::get(const std::string& name) const
{
	return _pImpl->get(name);
}


Document& SOAPElement::document()
{
	return _pImpl->document();
}


const std::string& SOAPElement::envelopeTag() const
{
	return _pImpl->envelopeTag();
}


const std::string& SOAPElement::headerTag() const
{
	return _pImpl->headerTag();
}


const std::string& SOAPElement::bodyTag() const
{
	return _pImpl->bodyTag();
}


} } // namespace Poco::Web
